#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "../dsk.h"

/* OLD namespace_name namespace_type_name namespace_func_name namespace_enum_name
       full_type_name full_func_name full_enum_name
       base_type_name base_func_name base_enum_name */
/* Sets Namespace namespace NAMESPACE
        Typename typename TYPENAME
        Namespace__Typename namespace__typename NAMESPACE__TYPENAME
   Maybe sets (for structs + unions):
        Category CATEGORY
 */

typedef enum
{
  RENDER_MODE_H_FILE,
  RENDER_MODE_C_FILE
} RenderMode;

#if 0
#define dsk_print(ctx, format) \
  do{ dsk_print_push (ctx); \
      dsk_print_set_string (ctx, "filename", __FILE__); \
      dsk_print_set_uint (ctx, "lineno", __LINE__); \
      dsk_print (ctx, "/* $filename:$lineno */"); \
      dsk_print_pop (ctx); \
      dsk_print (ctx, format); \
  } while(0)
#else
#define dsk_print(ctx, format) dsk_print(ctx, format)
#endif

static const char description[] =
      "Produce C bindings for the xml parsers\n"
      "generated by DskXmlBinding.\n\n"
      "Renders a .h file which contains the prototypes,\n"
      "and a .c file which contains the data DskXmlBindingType structures.\n";

static DskXmlBinding *binding;

static DSK_CMDLINE_CALLBACK_DECLARE (handle_searchpath)
{
  DSK_UNUSED (arg_name);
  DSK_UNUSED (error);
  dsk_xml_binding_add_searchpath (binding,
                                  arg_value,
                                  (const char *) callback_data);
  return DSK_TRUE;
}

#if 0
static int pstrcmp (const void *a, const void *b)
{
  const char *A = * (char **) a;
  const char *B = * (char **) b;
  return strcmp (A, B);
}
#endif

static void set_string_ns (DskPrint *ctx,
                           const char *var,
                           const char *name,
                           dsk_boolean uc_first,
                           dsk_boolean uc_nonfirst)
{
  char *str = dsk_malloc (strlen (name) * 2 + 1);
  char *at = str;
  const char *in = name;
  dsk_boolean next_is_first = DSK_TRUE;
  while (*in)
    {
      if (*in == '.')
        {
          *at++ = '_';
          *at++ = '_';
          in++;
          next_is_first = DSK_TRUE;
        }
      else if (*in == '_' || *in == '-')
        {
          next_is_first = DSK_TRUE;
          in++;
        }
      else
        {
          if (( next_is_first && uc_first)
           || (!next_is_first && uc_nonfirst))
            *at++ = dsk_ascii_toupper (*in);
          else
            *at++ = dsk_ascii_tolower (*in);
          in++;
          next_is_first = DSK_FALSE;
        }
    }
  *at = 0;
  dsk_print_set_string (ctx, var, str);
  dsk_free (str);
}

static void
set_struct_uppercase (DskPrint *ctx, const char *var, const char *value)
{
  const char *in = value;
  char *str = dsk_malloc (strlen (value) * 2 + 1);
  char *out = str;
  while (*in)
    {
      if (in != value && dsk_ascii_isupper (*in))
        *out++ = '_';
      *out++ = dsk_ascii_toupper (*in);
      in++;
    }
  *out = 0;
  dsk_print_set_string (ctx, var, str);
  dsk_free (str);
}
static void
set_struct_lowercase (DskPrint *ctx, const char *var, const char *value)
{
  const char *in = value;
  char *str = dsk_malloc (strlen (value) * 2 + 1);
  char *out = str;
  while (*in)
    {
      if (in != value && dsk_ascii_isupper (*in))
        *out++ = '_';
      *out++ = dsk_ascii_tolower (*in);
      in++;
    }
  *out = 0;
  dsk_print_set_string (ctx, var, str);
  dsk_free (str);
}

static void
set_ctypename (DskPrint *ctx,
               const char *name,
               DskXmlBindingType *type)
{
  if (type->ctypename)
    {
      dsk_print_set_string (ctx, name, type->ctypename);
    }
  else
    {
      unsigned max_size = 3 * strlen (type->ns->name)  /* max possible expansion == a -> A__ */
                        + 2                     /* __ */
                        + strlen (type->name)   /* (no transformation on type-name itself) */
                        + 1;                    /* nul-terminate */
      char *str = dsk_malloc (max_size);
      char *at = str;
      const char *in = type->ns->name;
      dsk_boolean next_is_upper = DSK_TRUE;
      while (*in)
        {
          if (*in == '.')
            {
              *at++ = '_';
              *at++ = '_';
              in++;
              next_is_upper = DSK_TRUE;
            }
          else if (*in == '_' || *in == '-')
            {
              next_is_upper = DSK_TRUE;
              in++;
            }
          else
            {
              if (next_is_upper)
                *at++ = dsk_ascii_toupper (*in);
              else
                *at++ = dsk_ascii_tolower (*in);
              in++;
              next_is_upper = DSK_FALSE;
            }
        }
      *at++ = '_';
      *at++ = '_';
      strcpy (at, type->name);
      dsk_print_set_string (ctx, name, str);
      dsk_free (str);
    }
}

static void
set_boolean (DskPrint *ctx,
             const char *name,
             dsk_boolean value)
{
  dsk_print_set_string (ctx, name, value ? "DSK_TRUE" : "DSK_FALSE");
}

static void
render_member (DskPrint *ctx, DskXmlBindingStructMember *member)
{
  dsk_print_push (ctx);
  set_ctypename (ctx, "member_type", member->type);
  dsk_print_set_string (ctx, "member_name", member->name);
  if (member->quantity == DSK_XML_BINDING_REQUIRED
   || member->quantity == DSK_XML_BINDING_OPTIONAL)
    dsk_print_set_string (ctx, "maybe_star", "");
  else
    dsk_print_set_string (ctx, "maybe_star", "*");
  if (member->quantity == DSK_XML_BINDING_REQUIRED_REPEATED
   || member->quantity == DSK_XML_BINDING_REPEATED)
    dsk_print (ctx, "${indent}unsigned n_$member_name;");
  if (member->quantity == DSK_XML_BINDING_OPTIONAL)
    dsk_print (ctx, "${indent}dsk_boolean has_$member_name;");
  dsk_print (ctx, "${indent}$member_type $maybe_star$member_name;");
  dsk_print_pop (ctx);
}

static void
render_member_descriptor (DskPrint *ctx, DskXmlBindingStructMember *member)
{
  dsk_print_set_string (ctx, "member_name", member->name);
  switch (member->quantity)
    {
    case DSK_XML_BINDING_REQUIRED:
      dsk_print_set_string (ctx, "quantity", "DSK_XML_BINDING_REQUIRED");
      dsk_print_set_string (ctx, "qoffset", "0");
      break;
    case DSK_XML_BINDING_OPTIONAL:
      dsk_print_set_string (ctx, "quantity", "DSK_XML_BINDING_OPTIONAL");
      dsk_print_set_template_string (ctx, "qoffset", "offsetof ($full_type_name, has_$member_name)");
      break;
    case DSK_XML_BINDING_REPEATED:
    case DSK_XML_BINDING_REQUIRED_REPEATED:
      if (member->quantity == DSK_XML_BINDING_REPEATED)
        dsk_print_set_string (ctx, "quantity", "DSK_XML_BINDING_REPEATED");
      else
        dsk_print_set_string (ctx, "quantity", "DSK_XML_BINDING_REQUIRED_REPEATED");
      dsk_print_set_template_string (ctx, "qoffset", "offsetof ($full_type_name, n_$member_name)");
      break;
    }
  if (member->type->ns->name)
    set_string_ns (ctx, "member_namespace_func_name", member->type->ns->name, 0, 0);
  else
    dsk_print_set_string (ctx, "member_namespace_func_name", "dsk_xml_binding");
  set_struct_lowercase (ctx, "member_func_name", member->type->name);
  dsk_print_set_template_string (ctx, "member_c_type",
                                 "${member_namespace_func_name}__${member_func_name}__type");
  dsk_print (ctx,
             "  {\n"
             "    $quantity,\n"
             "    \"$member_name\",\n"
             "    $member_c_type,\n"
             "    $qoffset,\n"
             "    offsetof ($full_type_name, $member_name)\n"
             "  },");
}

static void
set_typenames (DskPrint               *ctx,
               DskXmlBindingType      *type)
{
  DskXmlBindingNamespace *ns = type->ns;
  dsk_print_set_string (ctx, "namespace_name", ns->name);
  set_string_ns (ctx, "namespace_func_name", ns->name, 0, 0);
  set_string_ns (ctx, "namespace_type_name", ns->name, 1, 0);
  set_string_ns (ctx, "namespace_enum_name", ns->name, 1, 1);

  dsk_print_set_string (ctx, "base_type_name", type->name);
  set_struct_uppercase (ctx, "base_enum_name", type->name);
  set_struct_lowercase (ctx, "base_func_name", type->name);
  dsk_print_set_template_string (ctx, "full_func_name",
                                 "${namespace_func_name}__$base_func_name");
  dsk_print_set_template_string (ctx, "full_enum_name",
                                 "${namespace_enum_name}__$base_enum_name");
  dsk_print_set_template_string (ctx, "full_type_name",
                                 "${namespace_type_name}__$base_type_name");
}

static void
render_alignment_test (DskPrint *ctx)
{
  dsk_print (ctx,
             "struct ${full_type_name}__AlignmentTest {\n"
             "  char a;\n"
             "  ${full_type_name} b;\n"
             "};");
}

static void
render_descriptor_body (DskPrint *ctx,
                        DskXmlBindingType *type)
{
  dsk_print_push (ctx);
  set_boolean (ctx, "is_struct", type->is_struct);
  set_boolean (ctx, "is_union", type->is_union);

  dsk_print_set_string (ctx, "category", type->is_union ? "union" : "struct");
  if (type->clear)
    dsk_print_set_template_string (ctx, "clear_func", "dsk_xml_binding_${category}_clear");
  else
    dsk_print_set_string (ctx, "clear_func", "NULL");

  if (type->ns)
    dsk_print_set_template_string (ctx, "ns", "${namespace_func_name}__namespace");
  else
    dsk_print_set_string (ctx, "ns", "NULL");
  if (type->name)
    dsk_print_set_template_string (ctx, "name_str", "\"$base_type_name\"");
  else
    dsk_print_set_string (ctx, "name_str", "NULL");

  dsk_print_set_template_string (ctx, "base_type_definition",
                 "{\n"
                 "    DSK_FALSE,    /* !is_fundamental */\n"
                 "    DSK_TRUE,     /* is_static */\n"
                 "    $is_struct,    /* is_struct */\n"
                 "    $is_union,     /* is_union */\n"
                 "    0,            /* ref_count */\n"
                 "    sizeof (${full_type_name}),\n"
                 "    offsetof (struct ${full_type_name}__AlignmentTest, b),\n"
                 "    $ns,\n"
                 "    $name_str,\n"
                 "    NULL,    /* ctypename==typename */\n"
                 "    dsk_xml_binding_${category}_parse,\n"
                 "    dsk_xml_binding_${category}_to_xml,\n"
                 "    $clear_func,\n"
                 "    NULL           /* finalize_type */\n"
                 "  }");

  if (type->is_struct)
    {
      DskXmlBindingTypeStruct *s = (DskXmlBindingTypeStruct*)type;
      dsk_print_set_uint (ctx, "n_members", s->n_members);
      dsk_print (ctx,
                 "{\n"
                 "  $base_type_definition,\n"
                 "  $n_members,\n"
                 "  (DskXmlBindingStructMember *) ${full_func_name}__members,\n"
                 "  (unsigned *) ${full_func_name}__members_sorted_by_name\n"
                 "};");
    }
  else
    {
      DskXmlBindingTypeUnion *u = (DskXmlBindingTypeUnion*)type;
      dsk_print_set_uint (ctx, "n_cases", u->n_cases);
      dsk_print (ctx,
                 "{\n"
                 "  $base_type_definition,\n"
                 "  $n_cases,\n"
                 "  offsetof ($full_type_name, variant),\n"
                 "  (DskXmlBindingUnionCase *) ${full_func_name}__cases,\n"
                 "  (unsigned *) ${full_func_name}__cases_sorted_by_name\n"
                 "};");
    }
  dsk_print_pop (ctx);
}

static void
render_file (DskXmlBindingNamespace *ns,
             const char *output_basename,
             RenderMode mode)
{
  DskPrint *ctx;
  char *name = dsk_malloc (strlen (output_basename) + 10);
  FILE *fp;
  unsigned i, j, k;
  const char *slash;
  strcpy (name, output_basename);
  switch (mode)
    {
    case RENDER_MODE_H_FILE: strcat (name, ".h"); break;
    case RENDER_MODE_C_FILE: strcat (name, ".c"); break;
    }
  fp = fopen (name, "w");
  if (fp == NULL)
    dsk_die ("error creating %s: %s", name, strerror (errno));

  ctx = dsk_print_new_fp_fclose (fp);
  dsk_print_set_string (ctx, "output_basename", output_basename);
  dsk_print_set_string (ctx, "output_filename", name);

  slash = strrchr (output_basename, '/');
  dsk_print_set_string (ctx, "output_basebasename",
                        slash ? (slash+1) : output_basename);

  dsk_print (ctx,
             "/* $output_filename -- generated by dsk-make-xml-binding */\n"
             "/* DO NOT HAND EDIT - changes will be lost */\n\n");
  switch (mode)
    {
    case RENDER_MODE_H_FILE:
      dsk_print (ctx, "#ifndef DSK_H__INCLUDED");
      dsk_print (ctx, "#include <dsk/dsk.h>");
      dsk_print (ctx, "#endif");
      dsk_print (ctx, "#include <stddef.h>");
      break;
    case RENDER_MODE_C_FILE:
      dsk_print (ctx, "#include \"$output_basebasename.h\"");
      break;
    }

  /* convert ns->name into camel-case, lowercase and uppercase strings */
  dsk_print_set_string (ctx, "namespace_name", ns->name);
  set_string_ns (ctx, "namespace_func_name", ns->name, 0, 0);
  set_string_ns (ctx, "namespace_type_name", ns->name, 1, 0);
  set_string_ns (ctx, "namespace_enum_name", ns->name, 1, 1);

  /* render typedefs for structures and unions */
  if (mode == RENDER_MODE_H_FILE)
    {
      for (i = 0; i < ns->n_types; i++)
        if (ns->types[i]->is_struct
         || ns->types[i]->is_union)
          {
            dsk_print_push (ctx);
            set_typenames (ctx, ns->types[i]);
            dsk_print (ctx, "typedef struct _$full_type_name $full_type_name;");
            dsk_print_pop (ctx);
          }
    }

  /* render c-enums for unions/enums */
  if (mode == RENDER_MODE_H_FILE)
    {
      dsk_print (ctx, "\n\n/* Enums for Unions and Enumerations */");
      for (i = 0; i < ns->n_types; i++)
        if (ns->types[i]->is_union)
          {
            DskXmlBindingTypeUnion *t = ((DskXmlBindingTypeUnion*)ns->types[i]);
            dsk_print (ctx, "typedef enum\n{");
            dsk_print_push (ctx);
            set_typenames (ctx, &t->base_type);
            for (j = 0; j < t->n_cases; j++)
              {
                dsk_print_push (ctx);
                set_struct_uppercase (ctx, "label", t->cases[j].name);
                dsk_print (ctx, "  ${full_enum_name}__$label,");
                dsk_print_pop (ctx);
              }
            dsk_print (ctx, "} ${full_type_name}_Type;");
            dsk_print_pop (ctx);
          }
    }

  /* Anonymous union-cases that are structures */
  if (mode == RENDER_MODE_C_FILE)
    {
      dsk_print (ctx, "\n\n/* === Anonymous Structures Inside Unions === */");
      for (i = 0; i < ns->n_types; i++)
        if (ns->types[i]->is_union)
          {
            dsk_print_push (ctx);
            set_typenames (ctx, ns->types[i]);

            DskXmlBindingTypeUnion *u = (DskXmlBindingTypeUnion*)ns->types[i];

            for (j = 0; j < u->n_cases; j++)
              if (u->cases[j].elide_struct_outer_tag)
                {
                  /* Define C structure */
                  DskXmlBindingTypeStruct *cs = (DskXmlBindingTypeStruct*)(u->cases[j].type);
                  dsk_print_set_string (ctx, "case_name", u->cases[j].name);
                  dsk_print (ctx, "\n/* $full_type_name.$case_name */");
                  dsk_print (ctx,
                             "struct _${full_type_name}__${case_name}\n"
                             "{");
                  dsk_print_set_string (ctx, "indent", "  ");
                  for (k = 0; k < cs->n_members; k++)
                    render_member (ctx, cs->members + k);
                  dsk_print (ctx, "};");
                  dsk_print (ctx, "typedef struct _${full_type_name}__${case_name} ${full_type_name}__${case_name};\n");

                  /* Render the AlignmentTest object */
                  dsk_print_push (ctx);
                  dsk_print_set_template_string (ctx, "full_type_name",
                                                 "${full_type_name}__$case_name");
                  dsk_print_set_template_string (ctx, "full_func_name",
                                                 "${full_func_name}__${case_name}");
                  render_alignment_test (ctx); /* uses full_type_name */

                  /* Define DskXmlBindingTypeStruct */
                  dsk_print (ctx,
                             "static const DskXmlBindingStructMember ${full_func_name}__members[] =\n{");
                  for (k = 0; k < cs->n_members; k++)
                    render_member_descriptor (ctx, cs->members + k);
                  dsk_print (ctx, "};");
                  dsk_print (ctx,
                             "static const unsigned ${full_func_name}__members_sorted_by_name[] =\n{");
                  for (k = 0; k < cs->n_members; k++)
                    {
                      dsk_print_push (ctx);
                      dsk_print_set_uint (ctx, "index", cs->members_sorted_by_name[k]);
                      dsk_print_set_string (ctx, "name", cs->members[cs->members_sorted_by_name[k]].name);
                      dsk_print (ctx, "  $index,   /* members[$index] = $name */");
                      dsk_print_pop (ctx);
                    }
                  dsk_print (ctx,
                             "};");

                  dsk_print (ctx, "static const DskXmlBindingTypeStruct ${full_func_name}__descriptor =");
                  render_descriptor_body (ctx, u->cases[j].type);

                  dsk_print (ctx,
                       "#define ${full_func_name}__type ((DskXmlBindingType*)&(${full_func_name}__descriptor))");
                  dsk_print_pop (ctx);
                }
            dsk_print_pop (ctx);
          }
    }


  /* render struct's and union's */
  dsk_print (ctx, "\n\n/* Structures and Unions */");
  for (i = 0; i < ns->n_types; i++)
    if (ns->types[i]->is_struct)
      {
        DskXmlBindingType *type = ns->types[i];
        DskXmlBindingTypeStruct *s = (DskXmlBindingTypeStruct *) type;
        dsk_print_push (ctx);
        set_typenames (ctx, type);
        switch (mode)
          {
          case RENDER_MODE_H_FILE:
            dsk_print (ctx, "struct _$full_type_name\n{");
            break;
          case RENDER_MODE_C_FILE:
            dsk_print (ctx, "static const DskXmlBindingStructMember ${full_func_name}__members[] =\n{");
            break;
          }
        for (j = 0; j < s->n_members; j++)
          {
            dsk_print_push (ctx);
            dsk_print_set_string (ctx, "indent", "  ");
            switch (mode)
              {
              case RENDER_MODE_H_FILE:
                render_member (ctx, s->members + j);
                break;
              case RENDER_MODE_C_FILE:
                render_member_descriptor (ctx, s->members + j);
                break;
              }
            dsk_print_pop (ctx);
          }
        dsk_print_pop (ctx);
        dsk_print (ctx, "};");
      }
    else if (ns->types[i]->is_union)
      {
        DskXmlBindingType *type = ns->types[i];
        DskXmlBindingTypeUnion *u = (DskXmlBindingTypeUnion *) type;
        dsk_print_push (ctx);
        set_typenames (ctx, type);
        switch (mode)
          {
          case RENDER_MODE_H_FILE:
            dsk_print (ctx, "struct _$full_type_name\n"
                            "{\n"
                            "  ${full_type_name}_Type type;\n"
                            "  union {");
            break;
          case RENDER_MODE_C_FILE:
            dsk_print (ctx, "static const DskXmlBindingUnionCase ${full_func_name}__cases[] =\n{");
            break;
          }
        for (j = 0; j < u->n_cases; j++)
          {
            DskXmlBindingType *ct = u->cases[j].type;
            dsk_print_push (ctx);
            dsk_print_set_string (ctx, "case_name", u->cases[j].name);
            switch (mode)
              {
              case RENDER_MODE_H_FILE:
                if (u->cases[j].elide_struct_outer_tag)
                  {
                    DskXmlBindingTypeStruct *cs = (DskXmlBindingTypeStruct*) ct;
                    dsk_assert (ct->is_struct);
                    dsk_print (ctx, "    struct {");
                    for (k = 0; k < cs->n_members; k++)
                      {
                        dsk_print_push (ctx);
                        dsk_print_set_string (ctx, "indent", "      ");
                        render_member (ctx, cs->members + k);
                        dsk_print_pop (ctx);
                      }
                    dsk_print (ctx, "    } $case_name;");
                  }
                else if (ct != NULL)
                  {
                    set_ctypename (ctx, "case_type", ct);
                    dsk_print (ctx, "    $case_type $case_name;");
                  }
                break;
              case RENDER_MODE_C_FILE:
                dsk_print_push (ctx);
                dsk_print_set_string (ctx, "name", u->cases[j].name);
                set_boolean (ctx, "elide_struct_outer_tag",
                             u->cases[j].elide_struct_outer_tag);

                if (u->cases[j].type && u->cases[j].type->ns == NULL)
                  {
                    dsk_print_set_template_string (ctx, "case_type",
             "${full_func_name}__${name}__type");
                  }
                else if (u->cases[j].type)
                  {
                    if (u->cases[j].type->ns->name)
                      set_string_ns (ctx, "namespace_func_name", u->cases[j].type->ns->name, 0, 0);
                    else
                      dsk_print_set_string (ctx, "namespace_func_name", "dsk_xml_binding");
                    set_struct_lowercase (ctx, "type_func_name", u->cases[j].type->name);
                    dsk_print_set_template_string (ctx, "case_type", "${namespace_func_name}__${type_func_name}__type");
                  }
                else
                  {
                    dsk_print_set_string (ctx, "case_type", "NULL");
                  }
                dsk_print (ctx,
                           "  {\n"
                           "    \"$name\",\n"
                           "    $elide_struct_outer_tag,\n"
                           "    $case_type\n"
                           "  },");
                dsk_print_pop (ctx);
                break;
              }
          }
        switch (mode)
          {
          case RENDER_MODE_H_FILE:
            dsk_print (ctx, "  } variant;\n"
                            "};");
            break;
          case RENDER_MODE_C_FILE:
            dsk_print (ctx, "};");
            break;
          }
        dsk_print_pop (ctx);
      }

  /* Render global structures (DskXmlBindingType{Struct,Union}, and
   * their members) */
  if (mode == RENDER_MODE_C_FILE)
    {
      dsk_print (ctx, "\n\n/* Descriptors */");
      for (i = 0; i < ns->n_types; i++)
        if (ns->types[i]->is_struct || ns->types[i]->is_union)
          {
            dsk_print_push (ctx);
            set_typenames (ctx, ns->types[i]);
            render_alignment_test (ctx);            /* uses full_type_name */

            if (ns->types[i]->is_struct)
              {
                DskXmlBindingTypeStruct *s = (DskXmlBindingTypeStruct*)ns->types[i];
                unsigned j;
                dsk_print_set_uint (ctx, "n_members", s->n_members);
                dsk_print (ctx, "const unsigned ${full_func_name}__members_sorted_by_name[] =\n{");
                for (j = 0; j < s->n_members; j++)
                  {
                    dsk_print_set_uint (ctx, "index", s->members_sorted_by_name[j]);
                    dsk_print_set_string (ctx, "name", s->members[s->members_sorted_by_name[j]].name);
                    dsk_print (ctx, "  $index, /* members[$index] = \"$name\" */");
                  }
                dsk_print (ctx, "};");
                dsk_print (ctx,
                           "const DskXmlBindingTypeStruct ${full_func_name}__descriptor =");
                render_descriptor_body (ctx, ns->types[i]);
              }
            else                /* is_union */
              {
                DskXmlBindingTypeUnion *u = (DskXmlBindingTypeUnion*)ns->types[i];
                unsigned j;
                dsk_print_set_string (ctx, "dsk_xml_binding_union_clear",
                                      ns->types[i]->clear != NULL
                                          ? "dsk_xml_binding_union_clear"
                                          : "NULL");
                dsk_print_set_uint (ctx, "n_cases", u->n_cases);

                dsk_print (ctx, "const unsigned ${full_func_name}__cases_sorted_by_name[] =\n{");
                for (j = 0; j < u->n_cases; j++)
                  {
                    dsk_print_set_uint (ctx, "index", u->cases_sorted_by_name[j]);
                    dsk_print_set_string (ctx, "name", u->cases[u->cases_sorted_by_name[j]].name);
                    dsk_print (ctx, "  $index, /* members[$index] = \"$name\" */");
                  }
                dsk_print (ctx, "};");
                dsk_print (ctx,
                           "const DskXmlBindingTypeUnion ${full_func_name}__descriptor =");
                render_descriptor_body (ctx, ns->types[i]);
              }
            dsk_print_pop (ctx);
          }
    }

  /* render descriptor declarations */
  if (mode == RENDER_MODE_H_FILE)
    {
    }

  /* render namespace object */
  switch (mode)
    {
    case RENDER_MODE_H_FILE:
      dsk_print (ctx, "\n\n/* Namespace Declaration */");
      dsk_print (ctx, "#define ${namespace_func_name}__namespace ((DskXmlBindingNamespace*)(&${namespace_func_name}__descriptor))");
      dsk_print (ctx, "\n\n/* Struct and Union DskXmlBindingTypes */");
      for (i = 0; i < ns->n_types; i++)
        if (ns->types[i]->is_struct
         || ns->types[i]->is_union)
          {
            dsk_print_push (ctx);
            set_typenames (ctx, ns->types[i]);
            dsk_print (ctx, "#define ${full_func_name}__type ((DskXmlBindingType*)(&${full_func_name}__descriptor))");
            dsk_print_pop (ctx);
          }
      dsk_print (ctx, "\n\n\n\n/* Private */\n"
                 "extern const DskXmlBindingNamespace ${namespace_func_name}__descriptor;");
      for (i = 0; i < ns->n_types; i++)
        if (ns->types[i]->is_struct
         || ns->types[i]->is_union)
          {
            dsk_print_push (ctx);
            set_typenames (ctx, ns->types[i]);
            dsk_print (ctx, "extern const DskXmlBindingType$Category ${ns_name}__descriptor;");
            dsk_print_pop (ctx);
          }
      break;
    case RENDER_MODE_C_FILE:
      dsk_print_set_string (ctx, "ns_name", ns->name);
      dsk_print_set_uint (ctx, "n_types", ns->n_types);
      dsk_print (ctx, "\n\n/* The Namespace */");
      if (ns->types_sorted_by_name)
        {
          for (i = 0; i < ns->n_types; i++)
            if (ns->types_sorted_by_name[i] != i)
              break;
        }
      else
        i = ns->n_types;
      if (i < ns->n_types)
        {
          /* needs sorting array */
          dsk_print_set_template_string (ctx, "types_sorted_by_name",
                                         "(unsigned *) ${namespace_func_name}__type_sorted_by_name");
          dsk_print (ctx, "static const unsigned $types_sorted_by_name[] =\n{");
          for (i = 0; i < ns->n_types; i++)
            {
              dsk_print_push (ctx);
              dsk_print_set_uint (ctx, "index", ns->types_sorted_by_name[i]);
              dsk_print_set_string (ctx, "name", ns->types[ns->types_sorted_by_name[i]]->name);
              dsk_print (ctx, "  $index,   /* types[$index] = $name */");
              dsk_print_pop (ctx);
            }
          dsk_print (ctx, "};");
        }
      else
        dsk_print_set_string (ctx, "types_sorted_by_name", "NULL");

      dsk_print (ctx, "static const DskXmlBindingType *${namespace_func_name}__type_array[] =\n{");
      for (i = 0; i < ns->n_types; i++)
        {
          dsk_print_push (ctx);
          set_struct_lowercase (ctx, "type_lowercase", ns->types[i]->name);
          dsk_print (ctx, "  ${namespace_func_name}__${type_lowercase}__type,");
          dsk_print_pop (ctx);
        }
      dsk_print (ctx, "};\n");

      dsk_print (ctx, "const DskXmlBindingNamespace ${namespace_func_name}__descriptor =\n"
                      "{\n"
                      "  DSK_TRUE,              /* is_static */\n"
                      "  \"$ns_name\",\n"            
                      "  $n_types,               /* n_types */\n"
                      "  (DskXmlBindingType **) ${namespace_func_name}__type_array,\n"
                      "  0,                     /* ref_count */\n"
                      "  $types_sorted_by_name\n"
                      "};");
      break;
    }

  dsk_free (name);
  dsk_print_free (ctx);
}

int main(int argc, char **argv)
{
  char *output_basename;
  char *namespace_name;
  DskXmlBindingNamespace *ns;
  DskError *error = NULL;

  dsk_cmdline_init ("Make XML C-Bindings", description, NULL, 0);
  dsk_cmdline_add_string ("output-basename",
                          "Directory and basename for output files",
                          "FILE_PREFIX",
                          DSK_CMDLINE_MANDATORY,
                          &output_basename);
  dsk_cmdline_add_string ("namespace",
                          "Namespace to generate prototypes/descriptors for",
                          "NS",
                          DSK_CMDLINE_MANDATORY,
                          &namespace_name);
  dsk_cmdline_add_func ("search-tree",
                        "Filesystem tree to search for format files",
                        "PATH",
                        DSK_CMDLINE_REPEATABLE,
                        handle_searchpath, "/");
  dsk_cmdline_add_func ("search-dotted",
                        "Filesystem area to search for format files; namespaces are separated by '.'",
                        "PATH",
                        DSK_CMDLINE_REPEATABLE,
                        handle_searchpath, ".");

  binding = dsk_xml_binding_new ();
  dsk_cmdline_process_args (&argc, &argv);

  ns = dsk_xml_binding_get_ns (binding, namespace_name, &error);
  if (ns == NULL)
    dsk_die ("getting namespace '%s': %s", namespace_name, error->message);
  render_file (ns, output_basename, RENDER_MODE_H_FILE);
  render_file (ns, output_basename, RENDER_MODE_C_FILE);

  dsk_xml_binding_free (binding);
  dsk_cleanup ();

  return 0;
}

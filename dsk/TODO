TESTS:
_ request header parsing
_ response header parsing
x http client stream: connection-close
x http client stream: content-length POST data, connection-close
x http client stream: transfer-encoding chunked POST data
x http client stream: transfer-encoding chunked content data
x http client stream: keepalive (GET,POST,content-length,chunked)
x http client stream: oddballs
  x transfer-encoding chunk extensions
  x transfer-encoding chunk trailer
  x multiline header lines (w/ indent)
_ http client stream: error conditions:
  x extra blank space at front of request [ignored blank space]
  x bad response code
  x bad transfer-encoding chunked format
  _ bad gzip data
  _ random data tests
  _ transport errors reading/writing
  _ post-data stream read errors
_ http client: request instead of request_options testing
  _ modify http-client test to be two-pass
  _ test error conditions
  _ audit that we don't use assert inappropriately
_ http client gzip content-encoding:
  x POST data, pre-gzipped, with size
  _ POST data, pre-gzipped, with chunked [valgrind "with size" case first]
  _ POST data, streaming, with chunked
  _ POST data, data in slab with size
    (gzip and provide content-length=compressed-size)
  x body, with size
  x body, streaming
  _ body, without auto-decompression
_ http server stream: content-length POST data
_ http server stream: transfer-encoding-chunked POST data
x http server stream: transfer-encoding-chunked content
_ http server stream: pipelining
_ http server stream: error conditions:
  _ extra blank space at front of request
  _ bad transfer-encoding chunked format
  _ bad gzip data
  _ random data tests
  _ transport errors reading/writing
  _ post-data stream read errors
_ tie http-server and client together with pipes
  X simple GET / close connection
  _ simple POST / close connection
  _ import 'test_keepalive' (from tests/test-http-client-stream-0)
x date parsing (each of the three formats)
x date printing RFC-822
x converting unixtime <=> DskDate 
x XML Parser: basics
x XML Parser: big documents
x XML Parser: error conditions
x XML Parser: comments
_ XML Parser: ignore doctype and processing-instructions
x XML Parser: multiple return paths
x XML Parser: namespace support
_ XML Parser: parse errors
_ XML Parser: strip whitespace (not implemented yet) 
x XML Parser: search for existing conformance test
_ XML Parser: XML conformance test: suck up entities included
_ octet-filter test harness [feed data is several ways]
  _ c-quote test
  _ hex test
  _ base64 test
  _ url-encode test
  _ byte doubler test
_ dsk_octet_filter_source()

WARNING CONDITIONS:
_ high trap counts?

TODO:
_ HTTP Client implementation (search for TODO in dsk-http-client.h)

x HTTP Client Stream        KEEP UNTIL DONE TESTING
  x content-encoding gzip
    x message body
    x POST data
      x make dsk_http_client_stream_request_new take a
	DskHttpClientStreamRequestOptions
      x add force_post_data_gzip to Options; if given a static buffer,
        compress at request time; if given a stream, make a post-data-encoder.
	content-length must be handled carefullly.

filters:
  x dsk_hex_encoder_new             
  x dsk_hex_decoder_new             
  x dsk_url_encoder_new             
  x dsk_url_decoder_new
  _ dsk_xml_encoder_new             
  _ dsk_quote_printable_new         
  _ dsk_unquote_printable_new      
  _ dsk_utf8_to_utf16_converter_new
  _ dsk_utf16_to_utf8_converter_new
  x dsk_byte_doubler_new           
  x dsk_byte_undoubler_new         
  x dsk_octet_filter_chain_new_take [steal from programs/dsk-octet-filter.c]
_ remove persistency support from DskClientStream !?!
_ dsk_buffer_transfer, dsk_buffer_drain: consolidate fragments
  if they are both small.
_ figure out a way to tune buffer allocations
  (perhaps a way to build to write a behavior log?)
_ Is the post_data hack of dsk_http_server_stream_respond() really ok?
_ Review dsk-dispatch API... has_idle and has_timeout are clearly bogus...
  implement epoll support.
_ Date:
  _ dsk_date_print_rfc850()
  _ dsk_date_print_iso8601()
_ HTTP Header Work:
  _ "no_cache" response:
    HTTP/1.1:
      Cache-Control: no-store, no-cache, must-revalidate
      Cache-Control: post-check=0, pre-check=0
    HTTP/1.0:
      Pragma: no-cache

_ HTTP Server Stream implementation
  _ content-encoding gzip
    _ POST data, with size
    _ POST data, with chunked
    _ POST data, without auto-decompression
    _ body, pre-gzipped, with size
    _ body, pre-gzipped, with chunked
    _ body, streaming, with chunked
    _ body, data in slab with size
      (gzip and provide content-length=compressed-size)
_ HTTP Server implementation
_ MIME Multipart Impl
_ XML implementation
  x xml node object
  x parser
  _ parser: suppress whitespace
  _ parser: UTF-16
  _ parser: other char encodings? iconv plugin?
  _ parser: parsing dtd headers:
    _ internal entities
    _ external entities (a config parameter?)
    _ validation?
    note: there should be a flag to disable/skip this
  _ printer / pretty-printer
_ JSON implementation
  _ parser
  _ printer
_ checksum implementations

LATER
_ SSL and HTTPS
_ YAML implementation
  _ parser
  _ printer

DOCUMENTATION
*everything needs docs, but just remind ourselves of subtle stuff*
_ pick a documentation standard

CODING STANDARDS
_ "len" or "length"?  ANSWER: length
_ size_t everywhere ?
_ DskClientStreamSource BUT DskOctetStreamSourceFd.
  Fix this inconsistency and come up with a policy for naming derived classes

#include <string.h>
#include <stdio.h>
#include "dang.h"
#include "default-parser.h"

/* --- Functions Generated by Lemon --- */
/* i wish they were prototyped by lemon */
void *DangDefaultParser_Alloc(void *(*mallocProc)(size_t));
void DangDefaultParser_(
  void *yyp,                   /* The parser */
  int yymajor,                 /* The major token code number */
  DangToken *yyminor,      /* The value for the token */
  DangParserDefault *parser
);
void DangDefaultParser_Free(
  void *p,                    /* The parser to be deleted */
  void (*freeProc)(void*)     /* Function used to reclaim memory */
);
void DangDefaultParser_Trace(FILE *TraceFILE, char *zTracePrompt);


DangParser *
dang_parser_create (DangParseOptions *options,
                    DangError       **error)
{
  if (strcmp (options->factory_name, "default") == 0)
    return dang_parser_factory_default.create_parser (&dang_parser_factory_default, options, error);
  else
    {
      dang_set_error (error, "no factory registration implemented");
      return NULL;
    }
}
    

dang_boolean
dang_parser_parse (DangParser *parser,
                   DangToken  *token,
                   DangError **error)
{
  return parser->parse (parser, token, error);
}

dang_boolean
dang_parser_end_parse (DangParser *parser,
                       DangError **error)
{
  return parser->end_parse (parser, error);
}

DangExpr *
dang_parser_pop_expr(DangParser *parser)
{
  DangExpr *rv;
  if (parser->results.len == 0)
    return NULL;
  rv = * (DangExpr **) parser->results.data;
  dang_util_array_remove (&parser->results, 0, 1);
  return rv;
}

void
dang_parser_destroy(DangParser *parser)
{
  parser->destroy (parser);
}

unsigned
dang_parser_get_n_results (DangParser *parser)
{
  return parser->results.len;
}

void
dang_parser_set_imports (DangParser *parser,
                         DangImports *imports)
{
  dang_imports_ref (imports);
  dang_imports_unref (parser->imports);
  parser->imports = imports;
}
#if 0
void dang_parser_factory_register (DangParserFactory *factory,
                                   const char        *name)
{
  ...
}
#endif

void
dang_parser_base_init        (DangParser        *parser)
{
  DANG_UTIL_ARRAY_INIT (&parser->results, DangExpr *);
}

void
dang_parser_push_expr        (DangParser        *parser,
                              DangExpr          *expr)
{
  dang_util_array_append (&parser->results, 1, &expr);
  dang_expr_ref (expr);
}

void
dang_parser_take_expr        (DangParser        *parser,
                              DangExpr          *expr)
{
  dang_util_array_append (&parser->results, 1, &expr);
}

void
dang_parser_base_clear (DangParser *parser)
{
  unsigned i;
  for (i = 0; i < parser->results.len; i++)
    dang_expr_unref (((DangExpr**)parser->results.data)[i]);
  dang_util_array_clear (&parser->results);
}

/* --- private --- */
static inline dang_boolean
finish_parse (DangParserDefault *def,
              DangError **error)
{
  if (def->errors.len > 0)
    {
      *error = dang_error_ref (*(DangError **)(def->errors.data));
      return FALSE;
    }
  return TRUE;
}

static dang_boolean
maybe_flush_bareword_dot_arr (DangParserDefault *def,
                              DangError **error)
{
  if (def->bareword_dot_arr.len > 0)
    {
      DangToken **bd_arr = def->bareword_dot_arr.data;
      unsigned i;
      for (i = 0; i < def->bareword_dot_arr.len; i++)
        {
          unsigned subtag = (i % 2) ? DANG_DEFAULTPARSER_TOKEN_DOT
                                    : DANG_DEFAULTPARSER_TOKEN_BAREWORD;
#if 0
          {
            char *str = bd_arr[i] ? dang_token_make_string (bd_arr[i], TRUE) : dang_strdup_printf ("null token");
            dang_warning ("[flush bareword] parse: tag=%u: %s", subtag, str);
            dang_free (str);
          }
#endif
          DangDefaultParser_ (def->lemon_parser, subtag, bd_arr[i], def);
          if (def->errors.len > 0)
            {
              *error = dang_error_ref (*(DangError **)(def->errors.data));
              return FALSE;
            }
        }
      dang_util_array_set_size (&def->bareword_dot_arr, 0);
    }
  return TRUE;
}

static dang_boolean
default_parse           (DangParser *parser,
                         DangToken  *token,     /* we take ownership */
                         DangError **error)
{
  DangParserDefault *def = (DangParserDefault *) parser;
  unsigned tag = 0;
  unsigned i;

  if (def->last_token)
    dang_token_unref (def->last_token);
  def->last_token = dang_token_ref (token);

  /* Compute tag. */
  switch (token->type)
    {
    case DANG_TOKEN_TYPE_OPERATOR:
      {
        static const struct {
          const char *op_str;
          unsigned tag;
        } ops[] = {
          { "(", DANG_DEFAULTPARSER_TOKEN_LPAREN },
          { ")", DANG_DEFAULTPARSER_TOKEN_RPAREN },
          { ",", DANG_DEFAULTPARSER_TOKEN_COMMA },
          { ";", DANG_DEFAULTPARSER_TOKEN_SEMICOLON },
          { "{", DANG_DEFAULTPARSER_TOKEN_LBRACE },
          { "}", DANG_DEFAULTPARSER_TOKEN_RBRACE },
          { "[", DANG_DEFAULTPARSER_TOKEN_LBRACKET },
          { "]", DANG_DEFAULTPARSER_TOKEN_RBRACKET },
          { "=", DANG_DEFAULTPARSER_TOKEN_OP_ASSIGN },
          { "+", DANG_DEFAULTPARSER_TOKEN_OP_PLUS },
          { "++", DANG_DEFAULTPARSER_TOKEN_OP_PLUSPLUS },
          { "-", DANG_DEFAULTPARSER_TOKEN_OP_MINUS },
          { "--", DANG_DEFAULTPARSER_TOKEN_OP_MINUSMINUS },
          { "*", DANG_DEFAULTPARSER_TOKEN_OP_TIMES },
          { "/", DANG_DEFAULTPARSER_TOKEN_OP_DIVIDE },
          { "%", DANG_DEFAULTPARSER_TOKEN_OP_MOD },
          { "<<", DANG_DEFAULTPARSER_TOKEN_OP_LEFT_SHIFT },
          { ">>", DANG_DEFAULTPARSER_TOKEN_OP_RIGHT_SHIFT },
          { "|", DANG_DEFAULTPARSER_TOKEN_OP_BITWISE_OR },
          /*{ "&", DANG_DEFAULTPARSER_TOKEN_OP_BITWISE_AND },    (overloaded--called AMPERSAND) */
          { "^", DANG_DEFAULTPARSER_TOKEN_OP_BITWISE_XOR },
          { "~", DANG_DEFAULTPARSER_TOKEN_OP_BITWISE_COMPLEMENT },
          { "<", DANG_DEFAULTPARSER_TOKEN_OP_LT },
          { "<=", DANG_DEFAULTPARSER_TOKEN_OP_LTEQ },
          { ">", DANG_DEFAULTPARSER_TOKEN_OP_GT },
          { ">=", DANG_DEFAULTPARSER_TOKEN_OP_GTEQ },
          { "==", DANG_DEFAULTPARSER_TOKEN_OP_EQUAL },
          { "!=", DANG_DEFAULTPARSER_TOKEN_OP_NOT_EQUAL },
          { "<=>", DANG_DEFAULTPARSER_TOKEN_OP_CMP },
          { "<>", DANG_DEFAULTPARSER_TOKEN_OP_CONCAT },
          { "<>=", DANG_DEFAULTPARSER_TOKEN_OP_CONCAT_ASSIGN },
          { "||", DANG_DEFAULTPARSER_TOKEN_OP_LOGICAL_OR },
          { "&&", DANG_DEFAULTPARSER_TOKEN_OP_LOGICAL_AND },
          { ":", DANG_DEFAULTPARSER_TOKEN_COLON },
          { ".", DANG_DEFAULTPARSER_TOKEN_DOT },
          { "->", DANG_DEFAULTPARSER_TOKEN_ARROW },
          { "?", DANG_DEFAULTPARSER_TOKEN_OP_QUESTION_MARK },
          { "&", DANG_DEFAULTPARSER_TOKEN_AMPERSAND },
          { "!", DANG_DEFAULTPARSER_TOKEN_OP_NOT },
          { "+=", DANG_DEFAULTPARSER_TOKEN_OP_PLUS_ASSIGN },
          { "-=", DANG_DEFAULTPARSER_TOKEN_OP_MINUS_ASSIGN },
          { "*=", DANG_DEFAULTPARSER_TOKEN_OP_TIMES_ASSIGN },
          { "%=", DANG_DEFAULTPARSER_TOKEN_OP_MOD_ASSIGN },
          { "/=", DANG_DEFAULTPARSER_TOKEN_OP_DIVIDE_ASSIGN },
          { "<<=", DANG_DEFAULTPARSER_TOKEN_OP_LEFT_SHIFT_ASSIGN },
          { ">>=", DANG_DEFAULTPARSER_TOKEN_OP_RIGHT_SHIFT_ASSIGN },
          { "|=", DANG_DEFAULTPARSER_TOKEN_OP_BITWISE_OR_ASSIGN },
          { "&=", DANG_DEFAULTPARSER_TOKEN_OP_BITWISE_AND_ASSIGN },
          { "^=", DANG_DEFAULTPARSER_TOKEN_OP_BITWISE_XOR_ASSIGN },
          { "||=", DANG_DEFAULTPARSER_TOKEN_OP_LOGICAL_OR_ASSIGN },
          { "&&=", DANG_DEFAULTPARSER_TOKEN_OP_LOGICAL_AND_ASSIGN },

          { "%%", DANG_DEFAULTPARSER_TOKEN_PERCENT_PERCENT },
        };
        if (def->look_for_langle)
          {
            if (token->v_operator.str[0] == '<')
              {
                if (token->v_operator.str[1] == 0)
                  {
                    /* Just put in langle */
                    tag = DANG_DEFAULTPARSER_TOKEN_LANGLE;
                  }
                else
                  {
                    /* I don't see why we'd have a multichar op here */
                    dang_set_error (error, "multichar operator not allowed (got %s) ("DANG_CP_FORMAT")",
                                    token->v_operator.str, 
                                    DANG_CP_ARGS (token->any.code_position));
                    return FALSE;
                  }
                def->langle_count++;
              }
          }
        if (def->langle_count > 0)
          {
            /* Look for '>' anywhere in the operator */
            if (strcmp (token->v_operator.str, ">") == 0)
              {
                tag = DANG_DEFAULTPARSER_TOKEN_RANGLE;
                def->langle_count--;
              }
            else if (strchr (token->v_operator.str, '>') != NULL)
              {
                DangToken *tmp_token;
                /* I suppose there's some way to make this better,
                   but i cannot think of a case where it's allowed
                   to have any other operators bunched up in the op-str,
                   so we only allow strings of repeated ">" characters. */
                for (i = 0; token->v_operator.str[i] != 0; i++)
                  if (token->v_operator.str[i] != '>')
                    {
                      dang_set_error (error, "multichar operator at this point must consist solely of '>': use spaces, maybe? (got %s) ("DANG_CP_FORMAT")",
                                      token->v_operator.str, 
                                      DANG_CP_ARGS (token->any.code_position));
                      return FALSE;
                    }
                tmp_token = dang_token_operator_take (dang_strdup (">"));
                dang_code_position_copy (&tmp_token->any.code_position,
                                         &token->any.code_position);
                for (i = 0; token->v_operator.str[i] != 0; i++)
                  if (!default_parse (parser, tmp_token, error))
                    return FALSE;
                def->langle_count -= i;
                dang_token_unref (tmp_token);
                return TRUE;
              }
          }
        def->look_for_langle = FALSE;
        if (tag == 0)
          {
            for (i = 0; i < DANG_N_ELEMENTS (ops); i++)
              if (strcmp (ops[i].op_str, token->v_operator.str) == 0)
                {
                  tag = ops[i].tag;
                  break;
                }
            if (strcmp (token->v_operator.str, ".") == 0
             && def->bareword_dot_arr.len % 2 == 1)
              {
                dang_util_array_append (&def->bareword_dot_arr, 1, &token);
                return TRUE;
              }
            if (i == DANG_N_ELEMENTS (ops))
              {
                dang_set_error (error, "bad operator '%s'",
                                token->v_operator.str);
                return FALSE;
              }
          }
      }
      break;
    case DANG_TOKEN_TYPE_BAREWORD:
      {
        static const struct {
          const char *word;
          unsigned tag;
        } reserved_words[] = {
            /* TODO: bsearch */
          { "void", DANG_DEFAULTPARSER_TOKEN_VOID },
          { "in", DANG_DEFAULTPARSER_TOKEN_IN },
          { "out", DANG_DEFAULTPARSER_TOKEN_OUT },
          { "inout", DANG_DEFAULTPARSER_TOKEN_INOUT },
          { "var", DANG_DEFAULTPARSER_TOKEN_VAR },
          { "for", DANG_DEFAULTPARSER_TOKEN_FOR },
          { "while", DANG_DEFAULTPARSER_TOKEN_WHILE },
          { "do", DANG_DEFAULTPARSER_TOKEN_DO },
          { "try", DANG_DEFAULTPARSER_TOKEN_TRY },
          { "catch", DANG_DEFAULTPARSER_TOKEN_CATCH },
          { "return", DANG_DEFAULTPARSER_TOKEN_RETURN },
          { "if", DANG_DEFAULTPARSER_TOKEN_IF },
          { "else", DANG_DEFAULTPARSER_TOKEN_ELSE },
          { "break", DANG_DEFAULTPARSER_TOKEN_BREAK },
          { "redo", DANG_DEFAULTPARSER_TOKEN_REDO },
          { "continue", DANG_DEFAULTPARSER_TOKEN_CONTINUE },
          { "goto", DANG_DEFAULTPARSER_TOKEN_GOTO },
          { "struct", DANG_DEFAULTPARSER_TOKEN_STRUCT },
          { "object", DANG_DEFAULTPARSER_TOKEN_OBJECT },
          { "new", DANG_DEFAULTPARSER_TOKEN_NEW },
          { "method", DANG_DEFAULTPARSER_TOKEN_METHOD },
          { "abstract", DANG_DEFAULTPARSER_TOKEN_ABSTRACT },
          { "mutable", DANG_DEFAULTPARSER_TOKEN_MUTABLE },
          { "private", DANG_DEFAULTPARSER_TOKEN_PRIVATE },
          { "protected", DANG_DEFAULTPARSER_TOKEN_PROTECTED },
          { "public", DANG_DEFAULTPARSER_TOKEN_PUBLIC },
          { "readonly", DANG_DEFAULTPARSER_TOKEN_READONLY },
          { "final", DANG_DEFAULTPARSER_TOKEN_FINAL },
          { "static", DANG_DEFAULTPARSER_TOKEN_STATIC },
          { "true", DANG_DEFAULTPARSER_TOKEN_TRUE },
          { "false", DANG_DEFAULTPARSER_TOKEN_FALSE },
          { "enum", DANG_DEFAULTPARSER_TOKEN_ENUM },
          { "union", DANG_DEFAULTPARSER_TOKEN_UNION },
          { "module", DANG_DEFAULTPARSER_TOKEN_MODULE },
          { "import", DANG_DEFAULTPARSER_TOKEN_IMPORT },
          { "use", DANG_DEFAULTPARSER_TOKEN_USE },
          { "as", DANG_DEFAULTPARSER_TOKEN_AS },
        };
        static const struct {
          const char *word;
          unsigned tag;
        } template_type_words[] = {
          { "function", DANG_DEFAULTPARSER_TOKEN_FUNCTION },
          { "tensor", DANG_DEFAULTPARSER_TOKEN_TENSOR },
          { "array", DANG_DEFAULTPARSER_TOKEN_ARRAY },
          { "vector", DANG_DEFAULTPARSER_TOKEN_VECTOR },
          { "matrix", DANG_DEFAULTPARSER_TOKEN_MATRIX },
          { "tree", DANG_DEFAULTPARSER_TOKEN_TREE },
        };
        for (i = 0; i < DANG_N_ELEMENTS (reserved_words); i++)
          if (strcmp (reserved_words[i].word, token->v_bareword.name) == 0)
            {
              tag = reserved_words[i].tag;
              break;
            }
        for (i = 0; i < DANG_N_ELEMENTS (template_type_words); i++)
          if (strcmp (template_type_words[i].word, token->v_bareword.name) == 0)
            break;
        if (i < DANG_N_ELEMENTS (template_type_words))
          {
            def->look_for_langle = TRUE;
            tag = template_type_words[i].tag;
          }
        else
          {
            def->look_for_langle = FALSE;
          }

        if (tag == 0)
          {
            if (def->bareword_dot_arr.len % 2 == 1)
              {
                tag = DANG_DEFAULTPARSER_TOKEN_BAREWORD;
                goto feed_parser;
              }
            else
              {
                char **names;
                char *names_small[8];
                DangToken **bd_arr;
                unsigned n_names;
                DangValueType *type;
                dang_util_array_append (&def->bareword_dot_arr, 1, &token);
                bd_arr = def->bareword_dot_arr.data;

                /* Is this sequence of bw_dot_pairs a type? */
                n_names = (def->bareword_dot_arr.len + 1) / 2;
                if (n_names <= DANG_N_ELEMENTS (names_small))
                  names = names_small;
                else
                  names = dang_new (char *, n_names);
                for (i = 0; i < n_names; i++)
                  names[i] = bd_arr[2*i]->v_bareword.name;
                //dang_warning ("calling dang_imports_lookup_type: n_names=%u, names[%u] = %s, names[%u] = %s", n_names, 0, names[0], n_names-1, names[n_names-1]);
                type = dang_imports_lookup_type (def->base.imports, n_names, names);
                if (type != NULL)
                  {
                    DangToken *old = token;
                    for (i = 0; i < n_names * 2 - 1; i++)
                      dang_token_unref (bd_arr[i]);
                    dang_util_array_set_size (&def->bareword_dot_arr, 0);
                    tag = DANG_DEFAULTPARSER_TOKEN_TYPE_TOKEN;
                    token = dang_token_literal_take (dang_value_type_type (),
                                                     dang_memdup (&type, sizeof(DangValueType*)));
                    dang_code_position_copy (&token->any.code_position, &old->any.code_position);
                    def->look_for_langle = FALSE;
                    goto feed_parser;
                  }
                return TRUE;
              }
          }

      }
      break;
    case DANG_TOKEN_TYPE_INTERPOLATED_STRING:
      def->look_for_langle = FALSE;
      tag = DANG_DEFAULTPARSER_TOKEN_INTERPOLATED_STRING;
      break;
    case DANG_TOKEN_TYPE_LITERAL:
      def->look_for_langle = FALSE;
      tag = DANG_DEFAULTPARSER_TOKEN_LITERAL;
      break;
    default:
      dang_assert_not_reached ();
    }

feed_parser:
  dang_assert (tag != 0);

  if (!maybe_flush_bareword_dot_arr (def, error))
    return FALSE;

#if 0
    {
      char *str = token ? dang_token_make_string (token, TRUE) : dang_strdup_printf ("null token");
      dang_warning ("parse: tag=%u: %s", tag, str);
      dang_free (str);
    }
#endif
  DangDefaultParser_ (def->lemon_parser, tag, token, def);
  return finish_parse (def, error);
}


static dang_boolean
default_end_parse (DangParser *parser,
                   DangError **error)
{
  DangParserDefault *def = (DangParserDefault *) parser;
  if (!maybe_flush_bareword_dot_arr (def, error))
    return FALSE;
  DangDefaultParser_ (def->lemon_parser, 0, NULL, def);
  return finish_parse (def, error);
}

static void             
default_destroy   (DangParser *parser)
{
  DangParserDefault *def = (DangParserDefault *) parser;
  DangDefaultParser_Free (def->lemon_parser, dang_free);
  if (def->last_token)
    dang_token_unref (def->last_token);
  dang_imports_unref (def->base.imports);
  dang_util_array_clear (&def->bareword_dot_arr);
  dang_parser_base_clear (parser);
  dang_free (parser);
}

static DangParser *
default_create_parser (DangParserFactory *factory,
                       DangParseOptions  *options,
                       DangError        **error)

{
  DangParserDefault *rv = dang_new (DangParserDefault, 1);
  unsigned start_tag = 0;
#if 0
  static dang_boolean inited = 0;
  if (!inited)
    {
      inited = 1;
      DangDefaultParser_Trace(stderr, "<default-parser>");
    }
#endif
  DANG_UNUSED (factory);
  DANG_UNUSED (error);
  dang_parser_base_init (&rv->base);
  rv->base.parse = default_parse;
  rv->base.end_parse = default_end_parse;
  rv->base.destroy = default_destroy;
  rv->base.imports = dang_imports_ref (options->imports);
  rv->lemon_parser = DangDefaultParser_Alloc (dang_malloc);
  rv->last_token = NULL;
  rv->look_for_langle = FALSE;
  rv->langle_count = 0;
  DANG_UTIL_ARRAY_INIT (&rv->errors, DangError *);
  DANG_UTIL_ARRAY_INIT (&rv->bareword_dot_arr, DangToken *);

  switch (options->mode)
    {
    case DANG_PARSE_MODE_TOPLEVEL:
      start_tag = DANG_DEFAULTPARSER_TOKEN_TOPLEVEL_STATEMENT_LIST;
      break;
    case DANG_PARSE_MODE_EXPR:
      start_tag = DANG_DEFAULTPARSER_TOKEN_TOPLEVEL_EXPR;
      break;
    case DANG_PARSE_MODE_TYPE:
      start_tag = DANG_DEFAULTPARSER_TOKEN_TOPLEVEL_TYPE;
      break;
    }
  dang_assert (start_tag != 0);
  DangDefaultParser_ (rv->lemon_parser, start_tag, NULL, rv);
  return &rv->base;
}

DangParserFactory dang_parser_factory_default =
{
  default_create_parser
};
